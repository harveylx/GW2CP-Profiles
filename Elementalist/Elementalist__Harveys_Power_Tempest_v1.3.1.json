{
	"@type": "profile_container",
	"build_ref": "https://snowcrows.com/builds/raids/elementalist/power-tempest",
	"configuration": {
		"Combat": {
			"BreakStun": true,
			"DefianceBreak": true,
			"EnableCombatBehaviour": false,
			"EnableCombatService": true,
			"EnableDownstateCombat": true,
			"EnablePetCombat": false,
			"RescuePets": false,
			"ResetSkillTransformations": true,
			"SwapRangerPets": false,
			"SwapWeapons": true,
			"WeaponFiller": false
		},
		"Targeting": {
			"EffectiveRangeAdjust": 1,
			"PreferMelee": false
		}
	},
	"default": 1,
	"export_config": 1,
	"game_modes": "100111",
	"global_script": [
		"enum SPECIAL {",
		"    flame_elemental = 25488,",
		"    lightning_storm = 5737,",
		"    lightning_orb = 30795,",
		"}",
		"",
		"enum ATTUNEMENTS {",
		"    fire_attunement = 5492,",
		"    water_attunement = 5493,",
		"    air_attunement = 5494,",
		"}",
		"",
		"enum ATTUNEMENT_INDEX {",
		"    fire = 1,",
		"    water = 2,",
		"    air = 3,",
		"    earth = 4,",
		"}",
		"",
		"enum OVERLOADS {",
		"    overload_air = 29719,",
		"}",
		"",
		"enum HEALS {",
		"    wash_the_pain_away = 29535,",
		"    elemental_harmony_fire = 34743,",
		"    elemental_harmony_air = 34724,",
		"    elemental_harmony_water = 34651,",
		"    elemental_harmony_earth = 34609,",
		"    ether_renewal = 5507,",
		"    signet_of_restoration = 5503,",
		"    arcane_brilliance = 21656,",
		"}",
		"",
		"enum DEFIANCE_BREAK {",
		"    cyclone = 30008,",
		"    tidal_surge = 30864,",
		"    arcane_wave = 5638",
		"}",
		"",
		"enum WEAPON_SKILLS {",
		"    # Fire",
		"    phoenix = 5675,",
		"    dragons_tooth = 5692,",
		"    wildfire = 29533,",
		"",
		"    # Water",
		"    shatterstone = 5538,",
		"    water_trident = 5510,",
		"",
		"    # Air",
		"    arc_lightning = 5526,",
		"}",
		"",
		"enum INSTANT_CASTS {",
		"    flame_barrage = 25499,",
		"    feel_the_burn = 30662,",
		"    lightning_strike = 5561, # air attunement only",
		"    blinding_flash = 5694 # air attunement only",
		"}",
		"",
		"const _ACTIVATION_TIME_CONFIG: Dictionary = {",
		"    29719: 2500,           # Overload Air",
		"    5510: 100,             # Water Trident",
		"    5538: 25,             # Shatterstone",
		"    30795: 453,            # Lightning Orb",
		"    5737: 1124,            # Lightning Storm",
		"    5675: 25,             # Phoenix",
		"    29533: 150,            # Wildfire",
		"    5692: 200             # Dragon's Tooh",
		"}",
		"",
		"const OVERLOAD_THRESHOLD: int = 5000",
		"var last_skill_cast_time: int = 0",
		"var skill_cast_count: int = 0",
		"var runnable: bool = false",
		"var skill_util: SkillUtility = get_skill_utility()",
		"var agent_util: AgentUtility = get_agent_utility()",
		"var geometry_util: GeometryUtility = get_geometry_utility()",
		"var character_util: CharacterUtility = get_character_utility()",
		"var _controlled_character: ControlledCharacter",
		"",
		"func _process(_delta: float) -> void:",
		"    if not _controlled_character:",
		"        _controlled_character = get_character_utility().get_cc()",
		"    if should_abort(_controlled_character, skill_util, geometry_util):",
		"        abort_action()",
		"    if(not runnable):",
		"        return",
		"    if not _evaluate_can_run():",
		"        toggle_combat_behavior(true)",
		"        return",
		"    toggle_combat_behavior(false)",
		"    if not is_combat_assist_enabled():",
		"        return",
		"    handle_instant_casts(_controlled_character, skill_util)",
		"",
		"func initialize() -> void:",
		"    if skill_util == null:",
		"        skill_util = get_skill_utility()",
		"    if agent_util == null:",
		"        agent_util = get_agent_utility()",
		"    if geometry_util == null:",
		"        geometry_util = get_geometry_utility()",
		"    if character_util == null:",
		"        character_util = get_character_utility()",
		"",
		"func select_skill(cc: ControlledCharacter, target: Agent, _skill_id_filter: Array = []) -> SkillDataItem:",
		"    if not _is_tempest() or not _are_weapons_valid():",
		"        runnable = false",
		"        return null",
		"",
		"    var next_skill: SkillDataItem = get_next_skill(cc, target, skill_util, agent_util)",
		"",
		"    if next_skill != null:",
		"        if _ACTIVATION_TIME_CONFIG.has(next_skill.id):",
		"            next_skill.activation_time = _ACTIVATION_TIME_CONFIG[next_skill.id] * 2",
		"",
		"        var distance = geometry_util.get_distance_between(cc, target, true)",
		"        var game_distance = geometry_util.convert_to_game_distance(distance)",
		"",
		"        if next_skill.skill_range != null and next_skill.skill_range != 0:",
		"            if game_distance > next_skill.skill_range:",
		"                return null",
		"        elif next_skill.skill_radius != null and next_skill.skill_radius != 0:",
		"            if game_distance > next_skill.skill_radius:",
		"                return null",
		"",
		"    return next_skill",
		"",
		"func get_next_skill(cc: ControlledCharacter, target: Agent, skill_utility: SkillUtility, agent_utility: AgentUtility) -> SkillDataItem:",
		"    var defiance: SkillDataItem = handle_defiance(skill_utility, agent_utility, target)",
		"    var special: SkillDataItem = handle_special(cc, skill_utility)",
		"    var overload: SkillDataItem = handle_overloads(cc, skill_utility)",
		"    var attunement: SkillDataItem = handle_attunement(skill_utility)",
		"    var weapon_skill: SkillDataItem = handle_weapon_skills(cc, skill_utility)",
		"",
		"    if not defiance == null:",
		"        return defiance",
		"    if not overload == null:",
		"        return overload",
		"    if not attunement == null:",
		"        return attunement",
		"    if not special == null:",
		"        return special",
		"    if not weapon_skill == null:",
		"        return weapon_skill",
		"    return null",
		"",
		"func is_currently_casting(cc: ControlledCharacter, skill: SkillDataItem) -> bool:",
		"    var cast_info: CastInfo = cc.get_cast_info()",
		"    if  not cast_info == null:",
		"        return skill.id == cast_info.skill_id",
		"    return false",
		"",
		"func handle_defiance(skill_utility: SkillUtility, agent_utility: AgentUtility, target: Agent) -> SkillDataItem:",
		"    if target != null:",
		"        if agent_utility.has_break_bar(target) and target.break_bar.state == 0:",
		"            if (get_current_attunement() == ATTUNEMENT_INDEX.air):",
		"                var cyclone: SkillDataItem = get_skill(DEFIANCE_BREAK.cyclone)",
		"                if not skill_utility.is_on_cooldown(cyclone):",
		"                    return cyclone",
		"            if (get_current_attunement() == ATTUNEMENT_INDEX.water):",
		"                var tidal_surge: SkillDataItem = get_skill(DEFIANCE_BREAK.tidal_surge)",
		"                if not skill_utility.is_on_cooldown(tidal_surge):",
		"                    return tidal_surge",
		"    return null",
		"",
		"func handle_attunement(skill_utility: SkillUtility) -> SkillDataItem:",
		"    var current_time: int = Time.get_ticks_msec()",
		"",
		"    if (get_current_attunement() != ATTUNEMENT_INDEX.air):",
		"        var air_attunement: SkillDataItem = get_from_skillbar(ATTUNEMENTS.air_attunement)",
		"        if skill_cast_count >= 2 and current_time - last_skill_cast_time >= 100:",
		"            skill_cast_count = 0  # reset for next cycle",
		"            return air_attunement",
		"        return null",
		"",
		"    else:",
		"        var overload_air: SkillDataItem = get_from_skillbar(OVERLOADS.overload_air)",
		"        var fire_attunement: SkillDataItem = get_from_skillbar(ATTUNEMENTS.fire_attunement)",
		"        var water_attunement: SkillDataItem = get_from_skillbar(ATTUNEMENTS.water_attunement)",
		"",
		"        if not skill_utility.is_on_cooldown(water_attunement) and skill_utility.get_remaining_cooldown_time(overload_air) > OVERLOAD_THRESHOLD:",
		"            return water_attunement",
		"        elif not skill_utility.is_on_cooldown(fire_attunement) and skill_utility.get_remaining_cooldown_time(overload_air) > OVERLOAD_THRESHOLD:",
		"            return fire_attunement",
		"    return null",
		"",
		"#func handle_weapon_skills(cc: ControlledCharacter, skill_utility: SkillUtility) -> SkillDataItem:",
		"    #var skills = []",
		"    #var overload_air = get_skill(OVERLOADS.overload_air)",
		"    ## Add skills based on current attunement",
		"    #if get_current_attunement() == ATTUNEMENT_INDEX.fire:",
		"        #skills = [",
		"            #get_from_skillbar(WEAPON_SKILLS.phoenix),",
		"            #get_from_skillbar(WEAPON_SKILLS.wildfire),",
		"            #get_from_skillbar(WEAPON_SKILLS.dragons_tooth)",
		"        #]",
		"    #elif get_current_attunement() == ATTUNEMENT_INDEX.water:",
		"        #skills = [",
		"            #get_from_skillbar(WEAPON_SKILLS.shatterstone),",
		"            #get_from_skillbar(WEAPON_SKILLS.water_trident)",
		"        #]",
		"    #elif get_current_attunement() == ATTUNEMENT_INDEX.air:",
		"        #skills = [",
		"            #get_from_skillbar(WEAPON_SKILLS.arc_lightning)",
		"        #]",
		"#",
		"    ## Check cooldown status for each skill",
		"    #for skill in skills:",
		"        #if skill != null and not skill_utility.is_on_cooldown(skill) and not is_currently_casting(cc, skill):",
		"            #if (skill.id == WEAPON_SKILLS.arc_lightning and skill_utility.get_remaining_cooldown_time(overload_air) < 1000):",
		"                #return skill",
		"            #return skill",
		"    #return null",
		"",
		"func handle_weapon_skills(cc: ControlledCharacter, skill_utility: SkillUtility) -> SkillDataItem:",
		"    var skills: Array[SkillDataItem] = []",
		"    var overload_air = get_skill(OVERLOADS.overload_air)",
		"    var current_time: int = Time.get_ticks_msec()",
		"",
		"    # Add skills based on current attunement",
		"    if get_current_attunement() == ATTUNEMENT_INDEX.fire:",
		"        skills = [",
		"            get_from_skillbar(WEAPON_SKILLS.phoenix),",
		"            get_from_skillbar(WEAPON_SKILLS.wildfire),",
		"            get_from_skillbar(WEAPON_SKILLS.dragons_tooth)",
		"        ]",
		"    elif get_current_attunement() == ATTUNEMENT_INDEX.water:",
		"        skills = [",
		"            get_from_skillbar(WEAPON_SKILLS.shatterstone),",
		"            get_from_skillbar(WEAPON_SKILLS.water_trident)",
		"        ]",
		"    elif get_current_attunement() == ATTUNEMENT_INDEX.air:",
		"        skills = [",
		"            get_from_skillbar(WEAPON_SKILLS.arc_lightning)",
		"        ]",
		"",
		"    # Check cooldown status for each skill",
		"    for skill in skills:",
		"        if skill != null and not skill_utility.is_on_cooldown(skill) and not is_currently_casting(cc, skill):",
		"            if (skill.id == WEAPON_SKILLS.arc_lightning and skill_utility.get_remaining_cooldown_time(overload_air) < 1000):",
		"                return skill",
		"",
		"            if get_current_attunement() == ATTUNEMENT_INDEX.fire:",
		"                if skill.id == WEAPON_SKILLS.phoenix:",
		"                    last_skill_cast_time = current_time + skill.get_activation_time()",
		"                    skill_cast_count = 1",
		"                elif (skill.id == WEAPON_SKILLS.wildfire or skill.id == WEAPON_SKILLS.dragons_tooth) and skill_cast_count == 1:",
		"                    last_skill_cast_time = current_time + skill.get_activation_time()",
		"                    skill_cast_count = 2",
		"            elif get_current_attunement() == ATTUNEMENT_INDEX.water:",
		"                if skill.id == WEAPON_SKILLS.shatterstone:",
		"                    last_skill_cast_time = current_time + skill.get_activation_time()",
		"                    skill_cast_count = 1",
		"                elif skill.id == WEAPON_SKILLS.water_trident and skill_cast_count == 1:",
		"                    last_skill_cast_time = current_time + skill.get_activation_time()",
		"                    skill_cast_count = 2",
		"",
		"            return skill",
		"    return null",
		"",
		"func handle_overloads(cc: ControlledCharacter, skill_utility: SkillUtility) -> SkillDataItem:",
		"    if (get_current_attunement() != ATTUNEMENT_INDEX.air):",
		"        return null",
		"    var overload_air: SkillDataItem = get_skill(OVERLOADS.overload_air)",
		"    if not skill_utility.is_on_cooldown(overload_air) and not is_currently_casting(cc, overload_air):",
		"        return overload_air",
		"    return null",
		"",
		"#func handle_special(cc: ControlledCharacter, skill_utility: SkillUtility) -> SkillDataItem:",
		"    #if (get_current_attunement() != ATTUNEMENT_INDEX.air):",
		"        #return",
		"    #var lightning_storm: SkillDataItem = get_skill(SPECIAL.lightning_storm)",
		"    #var lightning_orb: SkillDataItem = get_skill(SPECIAL.lightning_orb)",
		"    #var overload_air: SkillDataItem = get_skill(OVERLOADS.overload_air)",
		"    #if not skill_utility.is_on_cooldown(lightning_storm) and (skill_utility.get_remaining_cooldown_time(overload_air) < OVERLOAD_THRESHOLD) and not is_currently_casting(cc, lightning_storm):",
		"        #return lightning_storm",
		"    #if not skill_utility.is_on_cooldown(lightning_orb) and skill_utility.get_remaining_cooldown_time(overload_air) < OVERLOAD_THRESHOLD and not is_currently_casting(cc, lightning_orb):",
		"        #return lightning_orb",
		"    #return null",
		"",
		"func handle_special(cc: ControlledCharacter, skill_utility: SkillUtility) -> SkillDataItem:",
		"    if get_current_attunement() != ATTUNEMENT_INDEX.air:",
		"        return null",
		"",
		"    var lightning_storm: SkillDataItem = get_skill(SPECIAL.lightning_storm)",
		"    var lightning_orb: SkillDataItem = get_skill(SPECIAL.lightning_orb)",
		"    var overload_air: SkillDataItem = get_skill(OVERLOADS.overload_air)",
		"",
		"    if (",
		"       not skill_utility.is_on_cooldown(lightning_storm) and",
		"       skill_utility.get_remaining_cooldown_time(overload_air) < OVERLOAD_THRESHOLD and",
		"       not is_currently_casting(cc, overload_air) and",
		"       not is_currently_casting(cc, lightning_storm)",
		"    ):",
		"        return lightning_storm",
		"",
		"    if (",
		"       not skill_utility.is_on_cooldown(lightning_orb) and",
		"       skill_utility.get_remaining_cooldown_time(overload_air) < OVERLOAD_THRESHOLD and",
		"       not is_currently_casting(cc, overload_air) and",
		"       not is_currently_casting(cc, lightning_orb)",
		"    ):",
		"        return lightning_orb",
		"",
		"    return null",
		"",
		"func handle_instant_casts(cc: ControlledCharacter, skill_utility: SkillUtility) -> void:",
		"    # Assign default values if null",
		"    cc = cc if cc != null else get_character_utility().get_cc()",
		"    skill_utility = skill_utility if skill_utility != null else get_skill_utility()",
		"",
		"    var target = cc.selection",
		"",
		"    # Handle \"Feel the Burn\"",
		"    var feel_the_burn: SkillDataItem = get_from_skillbar(INSTANT_CASTS.feel_the_burn)",
		"    if feel_the_burn and not skill_utility.is_on_cooldown(feel_the_burn) and target != null:",
		"        if not feel_the_burn.skill_radius == null:",
		"            var distance = geometry_util.get_distance_between(cc, target, true)",
		"            var game_distance = geometry_util.convert_to_game_distance(distance)",
		"            if game_distance > feel_the_burn.skill_range:",
		"                return",
		"            cast_skill(feel_the_burn, target)",
		"",
		"    # Handle \"Flame Barrage\"",
		"    var flame_barrage: SkillDataItem = get_from_skillbar(INSTANT_CASTS.flame_barrage)",
		"    if flame_barrage and not skill_utility.is_on_cooldown(flame_barrage) and target != null:",
		"        if not feel_the_burn.skill_range == null:",
		"            var distance = geometry_util.get_distance_between(cc, target, true)",
		"            var game_distance = geometry_util.convert_to_game_distance(distance)",
		"            if game_distance > flame_barrage.skill_range:",
		"                return",
		"            cast_skill(flame_barrage, target)",
		"",
		"    # Handle \"Arc Lightning\"",
		"    var lightning_strike: SkillDataItem = get_from_skillbar(INSTANT_CASTS.lightning_strike)",
		"    if get_current_attunement() == ATTUNEMENT_INDEX.air and lightning_strike and not skill_utility.is_on_cooldown(lightning_strike) and target != null:",
		"        if not lightning_strike.skill_range == null:",
		"            var distance = geometry_util.get_distance_between(cc, target, true)",
		"            var game_distance = geometry_util.convert_to_game_distance(distance)",
		"            if game_distance > lightning_strike.skill_range:",
		"                return",
		"            cast_skill(lightning_strike, target)",
		"",
		"    # Handle \"Blinding Flash\"",
		"    var blinding_flash: SkillDataItem = get_from_skillbar(INSTANT_CASTS.blinding_flash)",
		"    if get_current_attunement() == ATTUNEMENT_INDEX.air and blinding_flash and not skill_utility.is_on_cooldown(blinding_flash) and target != null:",
		"        if not blinding_flash.skill_range == null:",
		"            var distance = geometry_util.get_distance_between(cc, target, true)",
		"            var game_distance = geometry_util.convert_to_game_distance(distance)",
		"            if game_distance > blinding_flash.skill_range:",
		"                return",
		"            cast_skill(blinding_flash, target)",
		"    return",
		"",
		"",
		"func should_abort(cc: ControlledCharacter, skill_utility: SkillUtility, geometry_utility: GeometryUtility) -> bool:",
		"    var arc_lightning = get_from_skillbar(WEAPON_SKILLS.arc_lightning)",
		"    var overload_air = get_from_skillbar(OVERLOADS.overload_air)",
		"    var lightning_orb = get_from_skillbar(SPECIAL.lightning_orb)",
		"",
		"    if get_current_attunement() == ATTUNEMENT_INDEX.air:",
		"        if (not skill_util.is_on_cooldown(overload_air) or not skill_util.is_on_cooldown(lightning_orb)) and skill_util.is_being_cast(arc_lightning):",
		"            if not overload_air.skill_radius == null:",
		"                var distance = geometry_util.get_distance_between(cc, cc.selection, true)",
		"                var game_distance = geometry_util.convert_to_game_distance(distance)",
		"                if game_distance > overload_air.skill_range:",
		"                    return false",
		"            return true",
		"        if skill_util.get_remaining_cooldown_time(overload_air) > OVERLOAD_THRESHOLD and skill_util.is_being_cast(arc_lightning):",
		"            return true",
		"    return false",
		"",
		"func _are_weapons_valid() -> bool:",
		"    var has_scepter: bool = get_weapon(true, false) == WeaponTypeEnum.Scepter",
		"    var has_warhorn: bool = get_weapon(false, false) == WeaponTypeEnum.Warhorn",
		"    if (not has_scepter):",
		"        Log.warn(\"Character does not have a Scepter equipped. Profile will not run\")",
		"        runnable = false",
		"    if (not has_warhorn):",
		"        Log.warn(\"Character does not have a Warhorn equipped. Profile will not run\")",
		"        runnable = false",
		"    runnable = true",
		"    return runnable",
		"",
		"func _is_tempest() -> bool:",
		"    # Hardcoded for now as there is a mismatch with the enums",
		"    if get_elite_spec_id() != 48:",
		"        Log.warn('Profile \"%s\" needs a Tempest. See profile description for instructions.' % [get_profile_name()])",
		"        runnable = false",
		"    runnable = true",
		"    return runnable",
		"",
		"func _evaluate_can_run() -> bool:",
		"    if not _is_tempest():",
		"        return false",
		"    return true",
		"",
		"func get_current_attunement() -> int:",
		"    return get_character_utility().get_profession_state()"
	],
	"last_updated": "2024-08-05 16:13:13",
	"profession_id": 6,
	"profession_name": "Elementalist",
	"profile_name": "Harveys Power Tempest v1.3.1",
	"skills": {
		"29719": {
			"activation_time": [
				false,
				3239
			]
		},
		"30662": {
			"skill_range": [
				true,
				600
			]
		}
	},
	"template_code": "[&DQYpLxE+MBfHEgAAwxIAAL4BAADLAAAAJgAAAAAAAAAAAAAAAAAAAAAAAAA=]"
}