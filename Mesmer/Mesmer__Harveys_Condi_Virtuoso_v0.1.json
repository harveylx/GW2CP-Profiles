enum SIGNETS {
    signet_of_illusions = 10247,
    signet_of_the_ether = 21750,
}

enum BLADESONG_SKILLS {
    bladesong_harmony = 62586,
    bladesong_sorrow = 62616,
    bladeturn_requiem = 62597,
}

enum PHANTASMALS {
    phantasmal_swordsman = 10174,
    phantasmal_warden = 10282,
}

enum WEAPON_SKILLS {
    thousand_cuts = 24755,
    bladecall = 69311,
    unstable_bladestorm = 62607,
}
const PHANTASMAL_SWAP_THRESHHOLD: float = 3000.0
const MAX_BLADES: int = 5
const MAX_BLADESONG_HARMONY_CHARGES: int = 2
const NO_BLADESONG_HARMONY_CHARGES: int = 0

var runnable: bool = false
var skill_util: SkillUtility = get_skill_utility()
var agent_util: AgentUtility = get_agent_utility()
var geometry_util: GeometryUtility = get_geometry_utility()
var character_util: CharacterUtility = get_character_utility()
var _weapon_swap_needed: bool = false
var _controlled_character: ControlledCharacter


func _process(_delta: float) -> void:
    if(not runnable):
        return
    if not _controlled_character:
        _controlled_character = get_character_utility().get_cc()
    if not is_combat_assist_enabled():
        return
    if not _evaluate_can_run():
        toggle_combat_behavior(true)
        return
    toggle_combat_behavior(false)
    if not get_agent_utility().player_is_in_combat(_controlled_character, false):
        return
    #_stow_observer(_controlled_character)
    _handle_instant_casts(_controlled_character, skill_util)

func initialize() -> void:
    if skill_util == null:
        skill_util = get_skill_utility()
    if agent_util == null:
        agent_util = get_agent_utility()
    if geometry_util == null:
        geometry_util = get_geometry_utility()
    if character_util == null:
        character_util = get_character_utility()

func select_skill(cc: ControlledCharacter, target: Agent, _skill_id_filter: Array = []) -> SkillDataItem:
    if(not _is_virtuoso() or not _are_weapons_valid()):
        runnable = false
        return null
    var next_skill: SkillDataItem = _get_next_skill(cc, target, skill_util)
    if _weapon_swap_needed and can_swap_weapons():
        _weapon_swap_handler()
    if next_skill == null:
        next_skill = get_skill_in_slot(SkillbarSlotEnum.Weapon1)
    return next_skill

func _get_next_skill(cc: ControlledCharacter, target: Agent, skill_utility: SkillUtility) -> SkillDataItem:
    var weaponskill: SkillDataItem = _handle_weapon_skills(skill_utility, target)
    var phantasmal: SkillDataItem = handle_phantasmals(skill_utility)
    var bladesong: SkillDataItem = _handle_bladesongs(skill_utility, cc)
    #var special: SkillDataItem = _handle_special(cc, skill_utility, target)
    #if not special == null:
        #return special
    if not phantasmal == null:
        return phantasmal
    if not bladesong == null:
        return bladesong
    if not weaponskill == null:
        return weaponskill
    return null

#func _handle_special(cc: ControlledCharacter, skill_utility: SkillUtility, target: Agent) -> SkillDataItem:
    #var phantasmal: SkillDataItem = handle_phantasmals(skill_utility)
    #var bladesong: SkillDataItem = _handle_bladesongs(skill_utility, cc)
    #var weaponskill: SkillDataItem = _handle_weapon_skills(skill_utility, target)
    #var bsh_charges: int = _get_bsh_charges(skill_utility)
    #if phantasmal == get_skill(PHANTASMALS.phantasmal_swordsman):
        #if not phantasmal == null:
            #return phantasmal
        #return null
    #if not bsh_charges == MAX_BLADESONG_HARMONY_CHARGES:
        #if not weaponskill == null:
            #return weaponskill
        #return null
    #if bsh_charges == MAX_BLADESONG_HARMONY_CHARGES:
        #if not bladesong == null:
            #return bladesong
        #return null
    #return null

func _handle_weapon_skills(skill_utility: SkillUtility, target: Agent) -> SkillDataItem:
    var bladecall: SkillDataItem = get_from_skillbar(WEAPON_SKILLS.bladecall)
    var unstable_bladestorm: SkillDataItem = get_from_skillbar(WEAPON_SKILLS.unstable_bladestorm)

    if unstable_bladestorm and not skill_utility.is_on_cooldown(unstable_bladestorm):
        return unstable_bladestorm
    if bladecall and not skill_utility.is_on_cooldown(bladecall):
        return bladecall
    return null

func _stow_observer(cc: ControlledCharacter):
    var cast_info: CastInfo = cc.get_cast_info()
    if not cast_info == null and cast_info.skill_id == PHANTASMALS.phantasmal_swordsman:
        _stow(cc)
        await get_tree().create_timer(0.7).timeout
        cast_skill(get_skill_in_slot(SkillbarSlotEnum.Weapon1), cc.selection)
    if not cast_info == null and cast_info.skill_id == PHANTASMALS.phantasmal_warden:
        _stow(cc)
        await get_tree().create_timer(0.35).timeout
        cast_skill(get_skill_in_slot(SkillbarSlotEnum.Weapon1), cc.selection)

func _weapon_swap_handler() -> void:
    switch_weapon_set()
    _weapon_swap_needed = false


func _handle_bladesongs(skill_utility: SkillUtility, cc: ControlledCharacter) -> SkillDataItem:
    var bladecount: int = _get_bladecount(cc)
    var bladesong_harmony_charges: int = _get_bsh_charges(skill_utility)
    var bladesong_sorrow: SkillDataItem = get_skill(BLADESONG_SKILLS.bladesong_sorrow)
    var bladesong_harmony: SkillDataItem = get_skill(BLADESONG_SKILLS.bladesong_harmony)
    var bladeturn_requiem: SkillDataItem = get_skill(BLADESONG_SKILLS.bladeturn_requiem)
    var signet_of_illusions: SkillDataItem = get_from_skillbar(SIGNETS.signet_of_illusions)

    var is_bladesong_sorrow_ready = not skill_utility.is_on_cooldown(bladesong_sorrow)
    var is_signet_of_illusions_ready = not skill_utility.is_on_cooldown(signet_of_illusions)
    var is_bladeturn_requiem_ready = not skill_utility.is_on_cooldown(bladeturn_requiem)

    # If bladecount is at max and bladesong sorrow is ready, and we can gain harmony charges
    if bladecount == MAX_BLADES and is_bladesong_sorrow_ready and bladesong_harmony_charges < MAX_BLADESONG_HARMONY_CHARGES:
        return bladesong_sorrow

    # If bladecount is at max and we already have harmony charges
    if bladecount == MAX_BLADES and bladesong_harmony_charges > NO_BLADESONG_HARMONY_CHARGES:
        return bladesong_harmony

    # If bladesong sorrow is on cooldown for a significant time, use signet of illusions
    var is_bladesong_sorrow_on_long_cooldown = skill_utility.is_on_cooldown(bladesong_sorrow) and skill_utility.get_remaining_cooldown_time(bladesong_sorrow) > 7000
    if is_signet_of_illusions_ready and is_bladesong_sorrow_on_long_cooldown and bladesong_harmony_charges == NO_BLADESONG_HARMONY_CHARGES:
        return signet_of_illusions

    # Use bladeturn requiem if all relevant skills are on cooldown
    if bladecount == MAX_BLADES and skill_utility.is_on_cooldown(bladesong_sorrow) and skill_utility.is_on_cooldown(signet_of_illusions) and skill_utility.is_on_cooldown(bladesong_harmony) and is_bladeturn_requiem_ready:
        return bladeturn_requiem

    return null


func handle_phantasmals(skill_utility: SkillUtility) -> SkillDataItem:
    var can_swap = can_swap_weapons()
    var phantasmal_swordsman: SkillDataItem = get_from_skillbar(PHANTASMALS.phantasmal_swordsman)
    var phantasmal_warden: SkillDataItem = get_from_skillbar(PHANTASMALS.phantasmal_warden)
    var sote: SkillDataItem = get_skill(SIGNETS.signet_of_the_ether)

    var phantasmal_swordsman_cd = skill_utility.get_remaining_cooldown_time(phantasmal_swordsman)
    var phantasmal_warden_cd = skill_utility.get_remaining_cooldown_time(phantasmal_warden)
    var sote_cd = skill_utility.get_remaining_cooldown_time(sote)

    var is_phantasmal_swordsman_ready = not skill_utility.is_on_cooldown(phantasmal_swordsman)
    var is_phantasmal_warden_ready = not skill_utility.is_on_cooldown(phantasmal_warden)
    var is_sote_ready = not skill_utility.is_on_cooldown(sote)

    # Check if weapon swap is needed due to Phantasmal Swordsman's cooldown
    if phantasmal_swordsman_cd > PHANTASMAL_SWAP_THRESHHOLD and can_swap:
        _weapon_swap_needed = true

    if not is_phantasmal_warden_ready:
        _weapon_swap_needed = true

    # If Phantasmal Swordsman is ready and in the skill bar, use it
    if is_phantasmal_swordsman_ready and skill_utility.is_in_skillbar(phantasmal_swordsman, get_skillbar()):
        return phantasmal_swordsman

    if is_phantasmal_warden_ready and skill_utility.is_in_skillbar(phantasmal_warden, get_skillbar()):
        return phantasmal_warden

    # If Phantasmal Warden is ready, in the skill bar, and SOTE cooldown conditions are met, use it
    if is_phantasmal_warden_ready and (sote_cd >= 2500 and sote_cd < 20000):
        return phantasmal_warden

    # If Phantasmal Warden cooldown is low and SOTE is ready, use SOTE
    if phantasmal_warden_cd <= 5000 and is_sote_ready:
        return sote

    # Check if weapon swap is needed due to Warden and SOTE cooldowns
    var should_swap_for_warden_and_sote = can_swap and skill_utility.is_on_cooldown(phantasmal_warden) and skill_utility.is_on_cooldown(sote)
    var sote_long_cd = sote_cd > 25000

    if should_swap_for_warden_and_sote or sote_long_cd:
        _weapon_swap_needed = true
    return null

func _get_bladecount(cc: ControlledCharacter) -> int:
    if cc == null:
        cc = get_character_utility().get_cc()
    return cc.powers[0].current

func _handle_instant_casts(cc: ControlledCharacter, skill_utility: SkillUtility):
    # Assign default values if null
    cc = cc if cc != null else get_character_utility().get_cc()
    skill_utility = skill_utility if skill_utility != null else get_skill_utility()

    var target = cc.selection
    var thousand_cuts: SkillDataItem = get_from_skillbar(WEAPON_SKILLS.thousand_cuts)
    if thousand_cuts and not skill_utility.is_on_cooldown(thousand_cuts) and target != null:
        cast_skill(thousand_cuts, target)

func _get_bsh_charges(skill_utility: SkillUtility) -> int:
    if skill_utility == null:
        skill_utility = get_skill_utility()
    return skill_utility.get_remaining_charges(get_skill(BLADESONG_SKILLS.bladesong_harmony), false)

func _is_virtuoso() -> bool:
    # Hardcoded for now as there is a mismatch with the enums
    if get_elite_spec_id() != 66:
        Log.warn('Profile "%s" needs a Virtuoso. See profile description for instructions.' % [get_profile_name()])
        runnable = false
    runnable = true
    return runnable

func _are_weapons_valid() -> bool:
    var has_dagger: bool = get_weapon(true, false) == WeaponTypeEnum.Dagger
    var has_sword_or_focus: bool = get_weapon(false, false) == WeaponTypeEnum.Sword or get_weapon(false, false) == WeaponTypeEnum.Focus
    if (not has_dagger):
        Log.warn("Character does not have a Dagger equipped. Profile will not run")
        runnable = false
    elif (not has_sword_or_focus):
        Log.warn("Character does not have a Sword or Focus equipped in the offhand. Profile will not run")
        runnable = false
    else:
        runnable = true
    return runnable

func _stow(cc: ControlledCharacter) -> void:
    cc.stow_weapon(true)
    cc.stow_weapon(false)

func _evaluate_can_run() -> bool:
    if not _is_virtuoso():
        Log.warn(
            (
                'Profile "%s" needs a Virtuoso. See profile description for instructions.'
                % [get_profile_name()]
            )
        )
        return false
    return true
